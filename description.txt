Предметная область (П.О.): Игра рыбалка

Описание :
Это текстовая игра о рыбалке, в которой пользоваетель выбирает различные места для рыбалки, удочки, наживку.Пользователь может ловить разные виды рыбы. В игре также присутствует магазин, где игрок может покупать дополнительное снаряжение за очки, заработанные во время рыбалки.

Объекты и их атрибуты:
1. Рыбак:
   - Имя
   - Опыт
   - Снасти (удочка, наживка)
   - Инвентарь (включая приобретенные удочки и наживку)
   - Очки (для покупки снаряжения)

2. Место рыбалки:
   - Тип (берег реки, выход на реку на лодке, мост)
   - Виды рыб
   - Доступные снасти

3. Рыбы:
   - Вид
   - Размер
   - Вес

4. Магазин:
   - Удочки и их цены
   - Наживка и ее цена

5. Игра:
   - Текущий рыбак
   - Текущий водоем
   - Счет игрока

Логика взаимодействия объектов:
- Игрок начинает игру, выбирая место для рыбалки и получая стандартное снаряжение.
- В магазине игрок может приобретать удочки и наживку за очки, которые он заработал, ловя рыбу.
- Перед каждой попыткой рыбалки игрок выбирает удочку и наживку из своего инвентаря.
- Ловля рыбы зависит от шансов, заданных для каждого вида рыбы, места рыбалки и выбранной удочки.
- Игрок может получить очки за пойманную рыбу, с учетом ее веса и размера.
- Есть шанс сломать удочку, если рыба слишком тяжелая для выбранной удочки.
- Игрок может продолжать рыбачить и улучшать свое снаряжение, пытаясь набрать как можно больше очков.
- Игра завершается, когда игрок решает выйти или у него заканчиваются удочки

=================================================================================
Лаба 1 переделанная
Программа выглядит следующим образом. Каждый класс записан в разные файлы.
Классы раскиданы по файлам это не несет никакой логики. Это просто для визуализации


Есть иерархия классов. Класс - родитель Fish 
У рыбы есть 3 поля, Название рыбы, вес, и цена за килограм.
А так же для взаимодействия с private переменными у нас сделаны public свойства. Weight, PricePerKilo.
То есть когда мы будем устанавливать значение переменной мы будем взаимодействовать через свойство.
и проверять чтоб передваемое значение не было меньше 0.
А так же а так же объявили абстрактный метод, который переопределен в каждом классе наследнике по своему. 
Вызов такого метода, когда мы будем вызывать его у объекта класса Fish(который однако внутри является его наследником) будет полиморфным 
вызовом. Происходит это например в
ПОЛИМОРФНЫЙ ВЫЗОВ
1. Класс FisherMan, метод ToString, когда мы проходимся в  цикле по списку рыб, однака каждая рыба Fish, является 
каким-либо более конкретным типом(CheapFish, PremiumFish, StandartFish) и вызывается метод DisplayInfo, определенный именно в более конкретном метде.
2. Отображение информации о всех рыбах метда FisherPlace. Когда мы проходимся по списку рыб, однака каждая рыба внутри по сути является 
какой то более конкретной рыбой


Наследники:
- CheapFish - дешевая рыба(бюджетная)
- StandartFish - стандартная рыба( и не дорогая и не премиум)
- PremiumFish - премиум рыба, самая крутая

Далее у нас создан класс - рыбак FisherMan
Каждый рыбак содержит внутри
- Объект класса паспортных данных(просто имя и фамилию вынесли в отедльный класс)
- Список пойманных рыб
- Свойство, которое считает цену которыю необходимо заплатить рыбаку ща выкуп(суммирет цену каждой пойманной рыбы*её вес)
- Метод добаления рыбы к рыбаку. Те когда рыбак поймал рыбу её записывают к нему в список
- метод ToString Он выводит паспортные данные о рыбаке, колличество пойманных рыб, а так же общую сумму для выкупа.
А так же проходимся циклом по списку пойманных рыб и записываем в информацию общую.

Так же есть класс Pond - типо водоем, он соержит в себе список рыб, в большом количестве, метод добавления и удаления
А так же возвращает копию списка рыб через свойство. Во второй лабе этот класс будет коллекцией.

Далее у нас создан клас FisherPlace
Там содержится список HashSet рыб(Только уникальные значения рыб, чтобы понимать какие у нас вобще есть)
Водоем(во второй лабе их станет 3, по одному для каждого типа рыб).
Список рыбаков
Методы:
 - Добавления нвого рыбака
 - Добавлене нвой рыбы(Добавляется в список рыб а так же в количестве переданном в водоем)
 - IndexValid, создан просто чтоб понимать корректно ли выбран индекс рыбака
 - DoFishing - рандомно генерируется индекс, чтобы достать рыбу из водоема, может выпасть неверный индекс
Если рыба поймается, то она добаится к рыбаку.


У нас есть класс Program в нем происходит взаимодейстиве с консолью.
Спрашивается какой элемент меню выбрать.

Дополнительно прописаны методы для пунктов меню:
- создание рыбы (Запрашивается название рыбы, вес и цена. 
Если цена рыбы меньше 10 то создается рыба под типом CheapFish,
10 до 40 StandartFish,
больше или равна 40, то Premium)
- создание рыбака(запрашивается имя и фамилию)
- Эмитирирование рыбалки

--------------
Лаба 2 
От нас требуют так называемой кастомной коллеккции и работы с интерфесом
Что я сделал.
Во первых я создал интерфейс IPond. Интерфейс это как шаблон того, что должен реализовывавть класс - реализатор
(там описаны методы и их сигнатура)
В самао верзу я написал
1. IPond<T> : IEnumerable<T> - это значит что тот калсс который будет реализовывать интерфейс IPond, должен реализовать интерфес
IEnumerable( он включает в себя метод GetEnumerator, подробнее описанно в самом классе, зачем он нужон)
2. where T : Fish, это значит что в тип T(обобщенние мы сможем запихнуть класс Fish или его наследников)
(обощение - мы указываем тип в таких скобочка <> при инциализации объекта класса. И с этим типом, внутри класса у нас будет происходить взаимодейсвтие)

3. Объявил методы и свойства которые хочу видеть в к лкассе Pond.
Далее я в классе Pond реализовал все необходимы методы(добавление, удаление, getenumerator) и свойства (count, количесвто выловленных рыб)


Теперь переходим в класс FisherPlace. Теперь у нас 3 водоема. Каждый водоем создан для отдельного типа рыб
Премиум, стандарт и дешевка

ОБРАЩАЮ ВНИМАНИЕ водоемы хранятся под типом IPond, то есть взаимодействие происходит черезе иинтерфейс.
Это необходимо для того, чтобы бы мы не привязываллись к конкретной реализации водоема, а могли объявляьть какую либо разную реализацию
Однако в конструкторе мы объявляем
 CheapFishes = new Pond<CheapFish>("Недорогие рыбы");
 Это значит что хоть мы и будем работаь с интерфейсом, однаков в нутри будет реализаци Pond.
 
Так же был изменен метод 
- добавления рыбы
- Рыбалки
- Просмотра информации о водоемах
1. Добавление тепрь когда нам приходит рыба, мы добавляем её в общий список и в зависимости от её типа добавляем в определенный водоём в переданном количестве
2. Тепрь симулятор рыбалки так же принимает на вход и индекс для водоема и в зависмости от этого передамет в теперь отдельно вынесенный метод необходимый водоем, чтобы
произвести рыбалку(теперь шанс что то поймать 50/50)
3. С выводом информации примерно так же, вынесли в отдельный метод который принимает водоемы обощенно и там собираем инфомрациию. Для каждого вобоема делаем вызов и инфу суммируем.
--------------------------
Ковариантность

Эту штуку необходимо поакзать
Создали инетерфес IPondCovariacnce, определили что он коваринтный дописав out перед буковй T
Обязали реализовать 2 коваринтных метода(коваринтный метод возращает тип Т)
1 метод - вернет весь список как массив
2 метод вернет элмент по переданному индекс(если элемента нет то null)
Реализовали мтеоды в классе Pond

И перейдем к демострации. Необходимо продемострировать вработу коваринтных интерфес в отдельном методе 
В самом низу класса Programm есть метод Covarioance там происходит магия и там все описано

Этот метод вызывается при старте програмы

Если кратнко- то ковариатность дает возмодсть рабоать с более обобщенным типом 
https://metanit.com/sharp/tutorial/3.27.php
